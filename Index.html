<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SBM Map App</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom right, #e0f7fa, #ffffff);
      margin: 0;
      padding: 20px;
    }

    .form-container {
      margin-bottom: 15px;
      max-width: 400px;
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    label {
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 6px;
      display: block;
    }

    select {
      width: 100%;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }

    #map {
      height: 1000px;
      width: 100%;
      margin-top: 20px;
      border-radius: 10px;
    }
  </style>
</head>

<body>
  <div class="form-container">
    <label for="sbmSelect">üîß Select SBM Machine ID:</label>
    <select id="sbmSelect" onchange="loadMapData()">
      <option>Loading...</option>
    </select>
  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
    let map;
    let routeLine;

    function loadSBMIds() {
      google.script.run.withSuccessHandler(function(ids) {
        const select = document.getElementById('sbmSelect');
        select.innerHTML = '';
        ids.forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          select.appendChild(option);
        });
        loadMapData();
      }).getSBMIds();
    }

    function loadMapData() {
      const sbmId = document.getElementById('sbmSelect').value;

      google.script.run.withSuccessHandler(function(locations) {
        if (map) {
          map.remove();
        }

      map = L.map('map').setView([25.989204287309803, 79.44831774753393], 13);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);


        locations.forEach(loc => {
          const marker = L.marker([loc.lat, loc.lng]).addTo(map);
          marker.bindPopup(`<strong>Ac Id:${loc.acid}<br>Name: ${loc.name}<br></strong>
            <button onclick="getDirections(${loc.lat}, ${loc.lng})">üß≠ Get Directions</button>`);
        });

      }).getLocationsBySBMId(sbmId);
    }

 function getDirections(destLat, destLng) {
  if (!navigator.geolocation) {
    alert("Geolocation not supported.");
    return;
  }

  navigator.geolocation.getCurrentPosition(position => {
    const userLat = position.coords.latitude;
    const userLng = position.coords.longitude;

    drawRoute(userLat, userLng, destLat, destLng);
  }, error => {
    alert("Geolocation error: " + error.message);
  });
}


function decodePolyline(str, precision = 5) {
  let index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null;
  const factor = Math.pow(10, precision);

  while (index < str.length) {
    shift = 0;
    result = 0;

    do {
      byte = str.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);

    const deltaLat = (result & 1) ? ~(result >> 1) : (result >> 1);
    lat += deltaLat;

    shift = 0;
    result = 0;

    do {
      byte = str.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);

    const deltaLng = (result & 1) ? ~(result >> 1) : (result >> 1);
    lng += deltaLng;

    coordinates.push([lat / factor, lng / factor]);
  }

  return coordinates;
}

















async function drawRoute(userLat, userLng, destLat, destLng) {
  const apiKey = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImZiZjJlZjRiODkzNzRjZDRiMTI4Y2ZlZWU3MTZhNTE1IiwiaCI6Im11cm11cjY0In0="; // Replace with your ORS key

  const body = {
    coordinates: [
      [userLng, userLat],
      [destLng, destLat]
    ]
  };

  try {
    const response = await fetch("https://api.openrouteservice.org/v2/directions/driving-car", {
      method: "POST",
      headers: {
        "Accept": "application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8",
        "Content-Type": "application/json",
        "Authorization": apiKey
      },
      body: JSON.stringify(body)
    });

    const data = await response.json();
    console.log("üì• ORS Response:", data);

    if (!data || !data.routes || data.routes.length === 0) {
      alert("‚ùå No route found.");
      return;
    }

    const encoded = data.routes[0].geometry;
    const coordinates = decodePolyline(encoded);

    if (window.routeLine) {
      map.removeLayer(window.routeLine);
    }

    // Decode returns [lat, lng] ‚Äî which Leaflet expects
    window.routeLine = L.polyline(coordinates, {
      color: 'blue',
      weight: 5
    }).addTo(map);

    map.fitBounds(window.routeLine.getBounds());

  } catch (err) {
    console.error("üö® Routing Error:", err);
    alert("Something went wrong while fetching directions.");
  }
}




       

    window.onload = loadSBMIds;
  </script>
</body>
</html>
